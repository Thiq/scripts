import * as _ from 'underscore';
import * as enderChest from 'ender-chest';

const table = enderChest.getTable('quests');
table.set('npcs', table.get('npcs') || []);

function getNpcRegistry() {
    return getPlugin('Citizens').getNPCRegistry();
}

function getNpcSpeech() {
    return getPlugin('Citizens').getSpeechFactory();
}

// each NPC GUID is bound to a collection of quest GUIDs. 
export class NPCFactory {
    private _registeredNpcs: QuestNPC[] = [];
    private _factory;

    /**
     * 
     * @param factory The QuestFactory for the NPCFactory. 
     */
    constructor(factory) {
        this._factory = factory;
        var npcs = table.get('npcs');
        for (var i = 0; i < npcs.length; i++) {
            var npc = npcs[i] as QuestNPC;
            this._registeredNpcs.push(npc);
        }
        console.log(`Loaded ${npcs.length} quest NPCs.`, 'd');
        eventHandler('player', 'interactEntity', (e) => {
            var player = e.player;
            var npc = getNpcRegistry().getNPC(e.getRightClicked());
            if (!npc) return;
            player.sendMessage('Valid NPC');
            var questNPC = this.getNPCByUUID(npc.getUniqueId());
            if (!questNPC) return;
            player.sendMessage('Valid quest NPC');
            if (this._factory.isQuesting(player)) return;
            var questNPC = this.getNPCByUUID(npc.getUniqueId());
            let nextQuest = null;
            for (var i = 0; i < questNPC.quests.length; i++) {
                var quest = questNPC.quests[i];
                if (this._factory.hasPlayerCompleted(player, quest)) continue;
                nextQuest = quest;
                break;
            }
            if (!nextQuest) return;
            this.activateQuest(player, npc, nextQuest);
            this._factory.addQuester(player, nextQuest);
        });
    }

    /**
     * 
     * @param { * } player The player the quest is being activated for.
     * @param { QuestNPC } npc The QuestNPC the quest originated from.
     * @param { string } questID The quest UUID to be activated.
     */
    activateQuest(player, npc, questName) {
        // this is where we do all the talking and shit. 
    }

    hasNPC(name: string): boolean {
        return _.any(this._registeredNpcs, { name: name });
    }

    getNPCByUUID(uuid: string): QuestNPC {
        return _.find(this._registeredNpcs, { uniqueID: uuid });
    }

    getNPCByName(name: string): QuestNPC {
        return _.find(this._registeredNpcs, { name: name });
    }

    getNPC(entity): QuestNPC {
        var npc = getNpcRegistry().getNPC(entity);
        return _.find(this._registeredNpcs, { uniqueID: npc.getUniqueId().toString() });
    }

    createNPC(name, location, quests?: string[], type?): QuestNPC {
        let npc = getNpcRegistry().createNPC(type || org.bukkit.entity.EntityType.PLAYER, name);
        var questNPC = new QuestNPC(name, npc.getUniqueId(), type);
        this._registeredNpcs.push(questNPC);
        if (quests) {
            quests.forEach(function(quest) {
                questNPC.addQuest(quest);
            });
        }
        npc.spawn(location);
        return questNPC;
    }

    removeNpc(entity) {
        let npc = getNpcRegistry().getNPC(entity);
        if (!npc) throw new Error('Entity is not an NPC');
        this._registeredNpcs[npc.getUniqueId()] = null;
    }

    /**
     * Gets the NPC the current player is looking at.
     * @param player The player requested.
     */
    getNPCPlayerIsLookingAt(player) {
        return getTargetNPC(player);
    }
}


export function getTargetNPC(src): QuestNPC {
    var entities = src.getNearbyEntities(10, 10, 10);
    var livingE = [];
    entities.forEach((entity) => {
        if (entity instanceof org.bukkit.entity.LivingEntity) livingE.push(entity); 
    });
    for (var i = 0; i < livingE.length; i++) {
        var e = livingE[i];
        var eyeLocation = src.getEyeLocation();
        var toEntity = e.getEyeLocation().toVector().subtract(eyeLocation.toVector());
        var dot = toEntity.normalize().dot(eyeLocation.getDirection());
        if (dot > 0.99) return getNpcRegistry().getNPC(e);
    }
    return null;
}

export class QuestNPC {
    name: string;
    uniqueID: string;
    type;
    quests: string[];

    constructor(name: string, uniqueID: string, type) {
        this.name = name;
        this.uniqueID = uniqueID.toString();
        this.type = type;
        this.quests = [];
        table.get('npcs').push(this);
        table.save();
    }

    addQuest(questID: string) {
        this.quests.push(questID);
    }

    removeQuest(questID: string) {
        this.quests.splice(this.quests.indexOf(questID));
    }

    getCitizen() {
        return getNpcRegistry().getByUniqueId(this.uniqueID);
    }
}
