import { Quest } from './quest';
import { QuestType, getQuestType } from './quest-actions';
import { QuestReward } from './rewards';
import { QuestObjective, QuestObjectiveCompletionStatus } from './objective';
import { NPCFactory, QuestNPC } from './npcs';
import { QuestTarget, getTargetTypeFromAction } from './target';
import { Scoreboard } from 'scoreboard';
import * as _ from 'underscore';
import * as enderChest from 'ender-chest';
import * as pf from 'pf';
import { Title } from 'titles';

const completePrefix = '\xA7a✔';
const incompletePrefix = '\xA7c✘';
const table = enderChest.getTable('quests');

export { Quest as Quest };
export { QuestType as QuestType };
export { QuestReward as QuestReward };
export { QuestObjective as QuestObjective };

var userPermission = registerPermission('thiq.quests.user', false);

export class QuestFactory {
    /**
     * An object of { questName: Quest }
     */
    registeredQuests = {};
    /**
     * An object of { playerUUID: QuestStatus }
     */
    activeQuests = {};
    /**
     * An object of { playerUUID: questUUID[] }
     */
    completedQuests = {};
    /**
     * The NPC factory for the quest factory.
     */
    npcFactory: NPCFactory = new NPCFactory(this);
    
    private loadQuests() {
        var existedQuests = table.get('quests') || {};
        let count = 0;
        for (var field in existedQuests) {
            var quest = existedQuests[field];
            var q = Quest.deserialize(quest);
            this.registeredQuests[field] = q;
            count++;
        }
        console.log(`Loaded ${count} quests.`, 'd');
    }

    private loadStatuses() {
        var onlinePlayers = Bukkit.getOnlinePlayers();
        for (var i = 0; i < onlinePlayers.length; i++) {
            var p = onlinePlayers[i];
            var status = QuestStatus.load(this, p);
        }
    }

    constructor() {
        this.loadQuests();
        this.loadStatuses();
        registerCommand({
            name: 'quests',
            description: 'Access to the quest commands',
            usage: '\xA7cUsage: /<command> <addquest|removequest|addnpc|removenpc|setquestnpc>',
            permission: registerPermission('thiq.quests.admin', 'op'),
            permissionMessage: consts.defaultPermissionMessage
        }, (sender, label, args: string[]) => {
            if (args.length == 0) {
                return;
            }
            let questName = '';
            switch(args[0]) {
                case 'addquest':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    var quest = new Quest(questName);
                    try {
                        this.addQuest(quest);
                        sender.sendMessage(`\xA7dSuccessfully create quest ${questName}!`);
                    } catch (ex) {
                        sender.sendMessage(`\xA7cFailed to add quest: ${ex.message}`);
                    }
                    return;
                case 'removequest':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    try {
                        this.removeQuest(questName);
                        sender.sendMessage(`\xA7dSuccessfully removed quest ${questName}!`);
                    } catch (ex) {
                        sender.sendMessage(`\xA7cFailed to remove quest: ${ex.message}`);
                    }
                    return;
                case 'addnpc':
                    var npcName = args[1];
                    var npcType = args[2]; // TODO implement
                    if (this.npcFactory.hasNPC(npcName)) {
                        sender.sendMessage('\xA7cAn NPC with that name already exists!');
                        return;
                    }
                    var npc = this.createNPC(npcName, sender.getLocation());
                    sender.sendMessage(`\xA7d${npcName} successfully spawned. Use /quests setquestnpc <your quest name> to set a quest!`);
                    return;
                case 'removenpc':
                    return;
                case 'setquestnpc':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    sender.sendMessage('\xA7dRight click the NPC this quest will be set to.');
                    let questCheck = eventHandler('player', 'interactEntity', (e) => {
                        if (e.player != sender) return;
                        let npc = this.npcFactory.getNPC(e.getRightClicked());
                        e.cancelled = true;
                        if (!npc) {
                            sender.sendMessage('\xA7cA non-NPC entity was clicked. Cancelling assignment.');
                        } else {
                            let quest = this.registeredQuests[questName];
                            if (!quest) {
                                quest = new Quest(questName);
                                this.addQuest(quest);
                                sender.sendMessage(`\xA7dCould not locate quest "${questName}". Created a new one with that name anyways.`);
                            }
                            if (npc.hasQuest(questName)) {
                                sender.sendMessage('\xA7cThis NPC already has that quest assigned to it! Cancelling setup.');
                            } else {
                                npc.addQuest(questName);
                                sender.sendMessage(`\xA7dSuccessfully added ${questName} to ${npc.name}!`);
                                table.save();
                            }
                            
                        }
                        questCheck.unregister();
                    });
                    
                    return;
                case 'getquests':
                    sender.sendMessage(this.registeredQuests);
                    return;
                case 'addobj':
                    var questObjs: QuestObjective[] = [];
                    for (var i = 1; i < args.length; i++) {
                        // each obj is input as ACTION_COUNT_TYPE
                        var item = args[i];
                        if (/^\w{1,}_\d{1}_[a-z0-9]{1,}(:[0-9])?$/ig.test(item)) {
                            // we're reading an OBJ
                            var action = item.split('_')[0];
                            var count = item.split('_')[1];
                            var t = item.split('_')[2];
                            var questType = getQuestType(action);
                            var target = new QuestTarget(getTargetTypeFromAction(questType), t);
                            var questObj = new QuestObjective(questType, target, questObjs.length, parseInt(count));
                            questObjs.push(questObj);
                        } else {
                            // we're reading the quest name
                            questName += (item + ' ');
                        }
                    }
                    var quest = this.registeredQuests[questName] as Quest;
                    questObjs.forEach((obj) => {
                        quest.objectives.push(obj);
                    });
                    for (var field in this.activeQuests) {
                        var s = this.activeQuests[field] as QuestStatus;
                        if (!s) continue;
                        s.updateScoreboard();
                    }
                    table.set('quests', _.mapObject(this.registeredQuests, (val, key) => {
                        return val;
                    }));
                    sender.sendMessage('\xA7dSuccessfully added the objectives to the quest!');
                    return;
                default:
                    sender.sendMessage(`Unknown quest arg ${args[0]}: use <addquest|removequest|addnpc|removenpc|setquestnpc>`);
            }
        });
        eventHandler('player', 'join', (e) => {
            this.loadQuester(e.player);
            console.log(`Loaded quest status for ${e.player.getUniqueId()}`, 'e');
        });
        eventHandler('player', 'quit', (e) => {
            this.saveQuester(e.player);
            console.log(`Saved quest status for ${e.player.getUniqueId()}`, 'e');
        });
    }

    canPlayerQuest(player): boolean {
        return player.hasPermission(userPermission) || player.isOp();
    }
    
    createNPC(name: string, location, quests?: string[], type?: string): QuestNPC {
        return this.npcFactory.createNPC(name, location, quests, type);
    }

    addQuest(quest: Quest): Quest {
        if (this.registeredQuests[quest.name] != undefined) throw new Error('A quest with that ID already exists');
        this.registeredQuests[quest.name] = quest;
        table.get('quests').push(quest);
        table.save();
        return quest;
    }

    removeQuest(questName: string) {
        if (!this.registeredQuests[questName]) throw new Error('A quest with that name doesn\'t exist');
        var quest = this.registeredQuests[questName] as Quest;
        this.registeredQuests[questName] = null;
        // remove quest from store?
    }

    addQuester(player, questName) {
        if (!this.registeredQuests[questName]) throw new Error(`A quest with the ID ${questName} does not exist`);
        if (this.activeQuests[player.getUniqueId()] != undefined && 
            !this.activeQuests[player.getUniqueId()].isCompleted) {
            throw new Error('This player is already embarked on a quest');
        } else {
            this.activeQuests[player.getUniqueId()] = undefined;
        }
        var status = new QuestStatus(this, player, this.registeredQuests[questName]);
        this.activeQuests[player.getUniqueId()] = status;
        let quest = this.registeredQuests[questName];
        let questTitle = new Title('New Quest:', quest.name)
                    .color('red')
                    .subColor('yellow')
                    .fadeIn(300)
                    .subFadeIn(1000)
                    .stay(1000)
                    .subStay(1000)
                    .fadeOut(1000)
                    .subFadeOut(1000);
        questTitle.send(player);
        this.saveQuester(player.getUniqueId());
    }

    hasPlayerCompleted(player, questID) {
        return this.completedQuests[player.getUniqueId()].indexOf(questID) > -1;
    }

    isQuesting(player) {
        return this.activeQuests[player.getUniqueId()] != undefined && 
        !this.activeQuests[player.getUniqueId()].isCompleted;
    }

    saveQuester(playerId) {
        var status = this.activeQuests[playerId] as QuestStatus;
        var profile = pf.getProfile(playerId);
        if (status) status.save();
        profile.set('quests', 'completedQuests', this.completedQuests[playerId]);
    }

    loadQuester(player) {
        var playerId = player.getUniqueId();
        // load the completed quests from the profile
        var profile = pf.getProfile(playerId);
        var completedQuests = profile.get('quests', 'completedQuests') || [];
        this.completedQuests[playerId] = completedQuests;
        // load the current quest
        var status = QuestStatus.load(this, player, this.registeredQuests);
        this.activeQuests[playerId] = status;
        if (status) 
            status.updateScoreboard();
    }

    unloadQuester(playerId) {
        var savePoint = this.saveQuester(playerId);
        if (!savePoint) return;
        delete(this.activeQuests[playerId]);
        delete(this.completedQuests[playerId]);
    }
}

export class QuestStatus {
    player;
    completionStatus: QuestObjectiveCompletionStatus[];
    scoreboard: Scoreboard;
    quest: string;
    factory: QuestFactory;

    constructor(factory: QuestFactory, player, quest?: Quest, compl: QuestObjectiveCompletionStatus[] = []) {
        this.factory = factory;
        this.player = player;
        this.completionStatus = compl;
        if (quest) {
            this.beginWatch(quest);
        }
    }

    private serialize() {
        var result = {
            playerId: this.player.getUniqueId().toString(),
            objectives: this.completionStatus.map(o => {
                return { id: o.obj.id, count: o.count };
            }),
            quest: this.quest
        }
        return result;
    }

    private static deserialize(player, data, factory: QuestFactory): QuestStatus {
        if (!data) return null;
        var status = new QuestStatus(factory, player);
        var quest = factory.registeredQuests[data.quest] as Quest;
        var objectives = data.objectives;
        for (var i = 0; i < objectives.length; i++) {
            var obj = objectives[i];
            var id = obj.id;
            var count = obj.count;
            var match = _.where(quest.objectives, { id: id })[0];
            var cStatus = new QuestObjectiveCompletionStatus(match, count || 0);
            status.completionStatus.push(cStatus);
        }
        return status;
    }

    private beginWatch(quest: Quest) {
        this.quest = quest.name;
        this.scoreboard = new Scoreboard(`\xA7e${quest.name}`);
        for (let i = 0; i < this.completionStatus.length; i++) {
            let status = this.completionStatus[i];
            let obj = this.completionStatus[i].obj;
            if (!obj || !obj.type) continue;
            let objText = status.toString();
            let score = this.scoreboard.addEntry(
                `${incompletePrefix}${objText}`, 
                0,
                obj.id);
            status.on('$progress', (sender: QuestObjectiveCompletionStatus, args) => {
                this.scoreboard.setEntry(obj.id, sender.count);
                this.save();
            });
            status.on('$completed', (sender: QuestObjectiveCompletionStatus, args) => {
                this.updateObjStatus(status);
                if (this.isComplete()) {
                    this.factory.completedQuests[this.player.getUniqueId()].push(this.quest);
                }
            });
            status.beginWatch(this.player);
            // we probably should call the "$completed" but if it's already there, chances are it was already called
            // and this could be used to get unlimited rewards from a quest
        }
        if (quest.showScoreboard) this.scoreboard.send(this.player);
    }

    save() {
        var id = this.player.getUniqueId();
        var profile = pf.getProfile(id);
        profile.set('quests', 'current', this.serialize()); 
    }

    static load(factory: QuestFactory, player): QuestStatus {
        var id = player.getUniqueId();
        var profile = pf.getProfile(id);
        var data = profile.get('quests', 'current');
        if (!data) return null;
        var loadedStatus = QuestStatus.deserialize(player, data, factory);
        if (!loadedStatus) return null;
        // activeQuest should return an object of QuestStatus
        var activeQuest = factory.registeredQuests[loadedStatus.quest];
        console.log(activeQuest);
        if (!activeQuest) return null;
        factory.activeQuests[id] = loadedStatus;
        loadedStatus.beginWatch(activeQuest);
        return loadedStatus;
    }

    updateObjStatus(obj: QuestObjectiveCompletionStatus) {
        let objText = obj.toString();
        if (obj.count >= obj.count)
            this.scoreboard.setEntry(obj.obj.id, obj.count, `${completePrefix}${objText}`);
        else 
            this.scoreboard.setEntry(obj.obj.id, obj.count, `${incompletePrefix}${objText}`);
    }

    updateScoreboard() {
        for (let i = 0; i < this.completionStatus.length; i++) {
            let obj = this.completionStatus[i];
            this.scoreboard.setEntry(obj.obj.id, obj.count);
        }
    }

    isComplete() {
        for (var i = 0; i < this.completionStatus.length; i++) {
            if (!this.completionStatus[i].isComplete()) return false;
        }
        return true;
    }

    destroy() {
        delete(this.completionStatus);
        delete(this.scoreboard);
    }
}
