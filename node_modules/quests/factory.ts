import { Quest } from './quest';
import { QuestType, getQuestType } from './quest-actions';
import { QuestReward } from './rewards';
import { QuestObjective } from './objective';
import { NPCFactory, QuestNPC } from './npcs';
import { Scoreboard } from 'scoreboard';
import * as _ from 'underscore';
import * as enderChest from 'ender-chest';
import * as pf from 'pf';
import { Title } from 'titles';

const completePrefix = '\xA7a✔';
const incompletePrefix = '\xA7c✘';
const table = enderChest.getTable('quests');

export { Quest as Quest };
export { QuestType as QuestType };
export { QuestReward as QuestReward };
export { QuestObjective as QuestObjective };

export class QuestFactory {
    /**
     * An object of { questName: Quest }
     */
    registeredQuests = {};
    /**
     * An object of { playerUUID: QuestStatus }
     */
    activeQuests = {};
    /**
     * An object of { playerUUID: questUUID[] }
     */
    completedQuests = {};
    /**
     * The NPC factory for the quest factory.
     */
    npcFactory: NPCFactory = new NPCFactory(this);
    
    private loadQuests() {
        table.set('quests', table.get('quests') || []);
        var existedQuests = table.get('quests');
        existedQuests.forEach((q) => {
            this.registeredQuests[q.name] = q;
        });
        console.log(`Loaded ${existedQuests.length} quests.`, 'd');
    }

    constructor() {
        this.loadQuests();
        registerCommand({
            name: 'quest',
            description: 'Access to the quest commands',
            usage: '\xA7cUsage: /<command> <addquest|removequest|addnpc|removenpc|setquestnpc>',
            permission: registerPermission('thiq.quests', 'op'),
            permissionMessage: consts.defaultPermissionMessage
        }, (sender, label, args: string[]) => {
            if (args.length == 0) {
                return;
            }
            let questName = '';
            switch(args[0]) {
                case 'addquest':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    var quest = new Quest(questName);
                    try {
                        this.addQuest(quest);
                        sender.sendMessage(`\xA7dSuccessfully create quest ${questName}!`);
                    } catch (ex) {
                        sender.sendMessage(`\xA7cFailed to add quest: ${ex.message}`);
                    }
                    return;
                case 'removequest':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    try {
                        this.removeQuest(questName);
                        sender.sendMessage(`\xA7dSuccessfully removed quest ${questName}!`);
                    } catch (ex) {
                        sender.sendMessage(`\xA7cFailed to remove quest: ${ex.message}`);
                    }
                    return;
                case 'addnpc':
                    var npcName = args[1];
                    var npcType = args[2]; // TODO implement
                    if (this.npcFactory.hasNPC(npcName)) {
                        sender.sendMessage('\xA7cAn NPC with that name already exists!');
                        return;
                    }
                    var npc = this.createNPC(npcName, sender.getLocation());
                    sender.sendMessage(`\xA7d${npcName} successfully spawned. Use /quest setquestnpc <your quest name> to set a quest!`);
                    return;
                case 'removenpc':
                    return;
                case 'setquestnpc':
                    for (var i = 1; i < args.length; i++) {
                        questName += args[i] + ' ';
                    }
                    sender.sendMessage('\xA7dRight click the NPC this quest will be set to.');
                    let questCheck = eventHandler('player', 'interactEntity', (e) => {
                        if (e.player != sender) return;
                        let npc = this.npcFactory.getNPC(e.getRightClicked());
                        e.cancelled = true;
                        if (!npc) {
                            sender.sendMessage('\xA7cA non-NPC entity was clicked. Cancelling assignment.');
                        } else {
                            let quest = this.registeredQuests[questName];
                            if (!quest) {
                                quest = new Quest(questName);
                                this.addQuest(quest);
                                sender.sendMessage(`\xA7dCould not locate quest "${questName}". Created a new one with that name anyways.`);
                            }
                            npc.addQuest(questName);
                            sender.sendMessage(`\xA7dSuccessfully added ${questName} to ${npc.name}!`);
                            table.save();
                        }
                        questCheck.unregister();
                    });
                    
                    return;
                case 'getquests':
                    sender.sendMessage(this.registeredQuests);
                    return;
                case 'addobj':
                    var questObjs: QuestObjective[] = [];
                    for (var i = 1; i < args.length; i++) {
                        // each obj is input as ACTION_COUNT_TYPE
                        var item = args[i];
                        if (/^\w{1,}_\d{1}_\w{1,}$/ig.test(item)) {
                            // we're reading an OBJ
                            var action = item.split('_')[0];
                            var count = item.split('_')[1];
                            var target = item.split('_')[2];
                            var block = itemStack({ type: target });
                            var questObj = new QuestObjective(getQuestType(action), block.getType(), parseInt(count));
                            questObjs.push(questObj);
                        } else {
                            // we're reading the quest name
                            questName += (item + ' ');
                        }
                    }
                    var quest = this.registeredQuests[questName] as Quest;
                    questObjs.forEach((obj) => {
                        quest.objectives.push(obj);
                    });
                    table.save();
                    sender.sendMessage('\xA7dSuccessfully added the objectives to the quest!');
                    return;
                default:
                    sender.sendMessage(`Unknown quest arg ${args[0]}: use <addquest|removequest|addnpc|removenpc|setquestnpc>`);
            }
        });
        eventHandler('player', 'join', (e) => {
            this.loadQuester(e.player);
            console.log(`Loaded quest status for ${e.player.getUniqueId()}`, 'e');
        });
        eventHandler('player', 'quit', (e) => {
            this.saveQuester(e.player);
            console.log(`Saved quest status for ${e.player.getUniqueId()}`, 'e');
        });
    }
    
    createNPC(name: string, location, quests?: string[], type?: string): QuestNPC {
        return this.npcFactory.createNPC(name, location, quests, type);
    }

    addQuest(quest: Quest): Quest {
        if (this.registeredQuests[quest.name] != undefined) throw new Error('A quest with that ID already exists');
        this.registeredQuests[quest.name] = quest;
        table.get('quests').push(quest);
        table.save();
        return quest;
    }

    removeQuest(questName: string) {
        if (!this.registeredQuests[questName]) throw new Error('A quest with that name doesn\'t exist');
        var quest = this.registeredQuests[questName] as Quest;
        this.registeredQuests[questName] = null;
        // remove quest from store?
    }

    addQuester(player, questName) {
        if (!this.registeredQuests[questName]) throw new Error(`A quest with the ID ${questName} does not exist`);
        if (this.activeQuests[player.getUniqueId()] != undefined && 
            !this.activeQuests[player.getUniqueId()].isCompleted) {
            throw new Error('This player is already embarked on a quest');
        } else {
            this.activeQuests[player.getUniqueId()] = undefined;
        }
        var status = new QuestStatus(this, player.getUniqueId(), this.registeredQuests[questName]);
        this.activeQuests[player.getUniqueId()] = status;
        let quest = this.registeredQuests[questName];
        let questTitle = new Title('New Quest:', quest.name)
                    .color('red')
                    .subColor('yellow')
                    .fadeIn(300)
                    .subFadeIn(1000)
                    .stay(1000)
                    .subStay(1000)
                    .fadeOut(1000)
                    .subFadeOut(1000);
        questTitle.send(player);
    }

    hasPlayerCompleted(player, questID) {
        return this.completedQuests[player.getUniqueId()].indexOf(questID) > -1;
    }

    isQuesting(player) {
        return this.activeQuests[player.getUniqueId()] != undefined && 
        !this.activeQuests[player.getUniqueId()].isCompleted;
    }

    saveQuester(playerId) {
        // to save a quest point, we need:
        // - player UUID
        // - quest UUID
        // - an array of the current counts of objectives
        // Simple, yes?
        var status = this.activeQuests[playerId] as QuestStatus;
        if (!status || status.isComplete()) status = undefined;
        var quest = this.registeredQuests[status.quest] as Quest;
        // create the current save point
        var savePoint = new QuestSavePoint(playerId.toString(), quest.name, status.objectives.map(e => {
            return e.currentCount;
        }));
        // persist the save point
        table.set(`qstr;${playerId}`, savePoint);
        // save completed quest line to the user profile
        var profile = pf.getProfile(playerId);
        profile.set('quests', 'completedQuests', this.completedQuests[playerId]);
        return savePoint;
    }

    loadQuester(player) {
        var playerId = player.getUniqueId();
        // load the completed quests from the profile
        var profile = pf.getProfile(playerId);
        var completedQuests = profile.get('quests', 'completedQuests') || [];
        this.completedQuests[playerId] = completedQuests;
        // load the current quest
        var savePoint = table.get(`qstr;${playerId}`);
        if (!savePoint) return;
        var status = this.readQuestStatusFromSave(savePoint, player);
        this.activeQuests[playerId] = status;
        status.updateScoreboard();
    }

    private readQuestStatusFromSave(save: QuestSavePoint, player) {
        var quest = this.registeredQuests[save.questName];
        var status = new QuestStatus(this, player, quest);
        for (let i = 0; i < save.objStates.length; i++) {
            let objState = save.objStates[i];
            let objCurrent = status.objectives[i];
            objCurrent.setCurrentStatus(objState);
            status.updateObjStatus(objCurrent);
            objCurrent.beginWatch(player);
        }
        return status;
    }

    unloadQuester(playerId) {
        var savePoint = this.saveQuester(playerId);
        if (!savePoint) return;
        delete(this.activeQuests[playerId]);
        delete(this.completedQuests[playerId]);
    }
}

/**
 * Represents a save point of a quest.
 */
export class QuestSavePoint {
    playerUUID: string;
    questName: string;
    objStates: number[] = [];

    constructor(playerUUID: string, questName: string, objStates: number[]) {
        this.playerUUID = playerUUID;
        this.questName = questName;
        this.objStates = objStates;
    }
}

export class QuestStatus {
    player;
    objectives: QuestObjective[];
    scoreboard: Scoreboard;
    quest: string;
    isCompleted = {};
    factory: QuestFactory;

    constructor(factory: QuestFactory, player, quest?: Quest) {
        this.factory = factory;
        this.player = player;
        this.objectives = quest.objectives || [];
        this.scoreboard = new Scoreboard(`\xA7e${quest.name}`);
        if (quest) {
            this.beginWatch(quest);
        }
    }

    private beginWatch(quest: Quest) {
        this.quest = quest.name;
            for (let i = 0; i < this.objectives.length; i++) {
                let obj = this.objectives[i];
                if (!obj || !obj.type) continue;
                let objText = `${obj.type.toString().toLowerCase()} ${obj.count} ${obj.target.toString().toLowerCase().replace('_', ' ')}`;
                let score = this.scoreboard.addEntry(
                    `${incompletePrefix}${objText}`, 
                    0,
                    obj.id);
                obj.on('$progress', (sender, args) => {
                    this.scoreboard.setEntry(obj.id, sender.currentCount);
                });
                obj.on('$completed', (sender, args) => {
                    this.updateObjStatus(obj);
                    this.isCompleted[sender.name] = true;
                    if (this.isComplete()) {
                        this.factory.completedQuests[this.player.getUniqueId()].push(this.quest);
                    }
                });
                obj.beginWatch(this.player);
                this.isCompleted[obj.id] = false;
            }
            if (quest.showScoreboard) this.scoreboard.send(this.player);
    }

    save(completedQuests) {
        var id = this.player.getUniqueId();
        var profile = pf.getProfile(id);
        table.set(`qstr;${id}`, this);
    }

    static load(factory: QuestFactory, player, availableQuests): QuestStatus {
        var id = player.getUniqueId();
        var profile = pf.getProfile(id);
        var activeStatus = profile.get('quests', 'activeQuest') as QuestStatus;
        // activeQuest should return an object of QuestStatus
        var activeQuest = availableQuests[activeStatus.quest];
        if (!activeQuest) throw new Error(`No quest matches the ID ${activeStatus.quest}`);
        activeStatus.beginWatch(activeQuest);
        return activeStatus;
    }

    updateObjStatus(obj: QuestObjective) {
        let objText = `${obj.type.toString().toLowerCase()} ${obj.count} ${obj.target.toString().toLowerCase().replace('_', ' ')}`;
        if (obj.currentCount >= obj.count)
            this.scoreboard.setEntry(obj.id, obj.currentCount, `${completePrefix}${objText}`);
        else 
            this.scoreboard.setEntry(obj.id, obj.currentCount, `${incompletePrefix}${objText}`);
    }

    updateScoreboard() {
        for (let i = 0; i < this.objectives.length; i++) {
            let obj = this.objectives[i];
            this.scoreboard.setEntry(obj.id, obj.currentCount);
        }
    }

    isComplete() {
        for (let id in this.isCompleted) {
            if (!this.isCompleted[id]) return false;
        }
        return true;
    }

    destroy() {
        delete(this.objectives);
        delete(this.isCompleted);
        delete(this.scoreboard);
    }
}
