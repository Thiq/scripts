var util = require('util');
var errors = require('errors');
var _ = require('underscore');

var REInput = require('./_re_input');
var REOutput = require('./_re_output');
var REDuplex = require('./_re_duplex');

function REEco() {
    this.registry = new Registry();
}

REEco.prototype.registerInput = function(reInput) {
    if (typeof reInput === 'object') return this.registerInput(new REInput(reInput));
}

REEco.prototype.registerOutput = function(reOutput) {
    if (typeof reOutput === 'object') return this.registerOutput(new REOutput(reOutput));
}

REEco.prototype.registerMachine = function(reMachine) {
    this.registry.registerType(reMachine);
    this.emit('registerType', reMachine);
}

REEco.prototype.initializeBlock = function(block, machine) {
    var registered = new RegisteredMachine(block, machine);
    this.registry.registerInstance(registered);
    this.emit('registerBlock', registered);
}

REEco.prototype.start = function() {
    this.registry.beginWatch();
    this.emit('start');
}

REEco.prototype.stop = function() {
    this.registry.stopWatch();
    this.emit('stop');
}

function Registry() {
    EventEmitter.call(this);
    this._registered = Object.create(null);
    this._machines = [];
}

Registry.prototype.beginWatch = function() {
    var self = this;
    this.emit('start');
    this.cancelObject = setInterval(function() {
        for (var i = 0; i < self._machines.length; ++i) {
            var machine = self._machines[i];
            machine.update(self);
        }
    }, 1000);
}

Registry.prototype.stopWatch = function() {
    cancelInterval(this.cancelObject);
    this.emit('stop');
}

Registry.prototype.registerType = function(machine) {
    if (this._registered[machine.name]) throw new errors.ERR_INVALID_ARG_VALUE('machine', machine, 'machine is already registered');
}

Registry.prototype.registerInstance = function(registeredMachine) {
    if (this._isRegistered(registeredMachine)) throw new errors.ERR_INVALID_ARG_VALUE('registeredMachine', registeredMachine, 'block is already a registered machine');
    this._machines.push(registeredMachine);
    this.emit('register', registeredMachine);
}

Registry.prototype._isRegistered = function(block) {
    return _.find(this._machines, function(m) {
        return m.block.getLocation() == block.getLocation();
    }) || false;
}

Registry.prototype.getNeighbor = function(block, blockFace) {
    var instance = this._isRegistered(block);
    if (!instance) return null;
    if (typeof blockFace === 'string') {
        blockFace = org.bukkit.block.BlockFace.valueOf(blockFace.toUpperCase());
    }

    var neighbor = block.getRelative(blockFace);
    var neighborInstance = this._isRegistered(neighbor);
    return neighborInstance;
}

function RegisteredMachine(block, machine) {
    this.block = block;
    this.machine = machine;
}

RegisteredMachine.prototype.update = function(registry) {
    this.machine.update(this, registry);
}

REEco.Registry = Registry;
REEco.RegisteredMachine = RegisteredMachine;

module.exports = REEco;